{"name":"Snap for Beginners","tagline":"Sample Chapter: Digestive Functors (Form Processing)","body":"# Digestive Functors\r\n\r\nDigestive functors are one way to do form processing in Haskell. In this chapter we will build up a sample application to see how to accept and validate form input and render forms and errors with the digestive functors package.\r\n\r\nThen, we'll move into a deeper exploration and examine all of the possible options digestive functors gives us.\r\n\r\n## Building a Digestive Functors Flow\r\n\r\nTo start off, we need a scaffold. We'll create a new folder named `df-one` and create a new scaffolding app inside it:\r\n\r\n```bash\r\nmkdir df-one\r\ncd df-one\r\nsnap init\r\n```\r\n\r\nAlternatively, check out the code in `code/digestive-functors/df-one`, which has the completed code.\r\n\r\nOur `src/Site.hs` currently looks as such:\r\n\r\n```haskell\r\n{-# LANGUAGE OverloadedStrings #-}\r\n\r\n------------------------------------------------------------------------------\r\n-- | This module is where all the routes and handlers are defined for your\r\n-- site. The 'app' function is the initializer that combines everything\r\n-- together and is exported by this module.\r\nmodule Site\r\n  ( app\r\n  ) where\r\n\r\n------------------------------------------------------------------------------\r\nimport           Control.Applicative\r\nimport           Data.ByteString (ByteString)\r\nimport           Data.Maybe\r\nimport qualified Data.Text as T\r\nimport           Snap.Core\r\nimport           Snap.Snaplet\r\nimport           Snap.Snaplet.Auth\r\nimport           Snap.Snaplet.Auth.Backends.JsonFile\r\nimport           Snap.Snaplet.Heist\r\nimport           Snap.Snaplet.Session.Backends.CookieSession\r\nimport           Snap.Util.FileServe\r\nimport           Heist\r\nimport qualified Heist.Interpreted as I\r\n------------------------------------------------------------------------------\r\nimport           Application\r\n\r\n\r\n------------------------------------------------------------------------------\r\n-- | Render login form\r\nhandleLogin :: Maybe T.Text -> Handler App (AuthManager App) ()\r\nhandleLogin authError = heistLocal (I.bindSplices errs) $ render \"login\"\r\n  where\r\n    errs = [(\"loginError\", I.textSplice c) | c <- maybeToList authError]\r\n\r\n\r\n------------------------------------------------------------------------------\r\n-- | Handle login submit\r\nhandleLoginSubmit :: Handler App (AuthManager App) ()\r\nhandleLoginSubmit =\r\n    loginUser \"login\" \"password\" Nothing\r\n              (\\_ -> handleLogin err) (redirect \"/\")\r\n  where\r\n    err = Just \"Unknown user or password\"\r\n\r\n\r\n------------------------------------------------------------------------------\r\n-- | Logs out and redirects the user to the site index.\r\nhandleLogout :: Handler App (AuthManager App) ()\r\nhandleLogout = logout >> redirect \"/\"\r\n\r\n\r\n------------------------------------------------------------------------------\r\n-- | Handle new user form submit\r\nhandleNewUser :: Handler App (AuthManager App) ()\r\nhandleNewUser = method GET handleForm <|> method POST handleFormSubmit\r\n  where\r\n    handleForm = render \"new_user\"\r\n    handleFormSubmit = registerUser \"login\" \"password\" >> redirect \"/\"\r\n\r\n\r\n------------------------------------------------------------------------------\r\n-- | The application's routes.\r\nroutes :: [(ByteString, Handler App App ())]\r\nroutes = [ (\"/login\",    with auth handleLoginSubmit)\r\n         , (\"/logout\",   with auth handleLogout)\r\n         , (\"/new_user\", with auth handleNewUser)\r\n         , (\"\",          serveDirectory \"static\")\r\n         ]\r\n\r\n\r\n------------------------------------------------------------------------------\r\n-- | The application initializer.\r\napp :: SnapletInit App App\r\napp = makeSnaplet \"app\" \"An snaplet example application.\" Nothing $ do\r\n    h <- nestSnaplet \"\" heist $ heistInit \"templates\"\r\n    s <- nestSnaplet \"sess\" sess $\r\n           initCookieSessionManager \"site_key.txt\" \"sess\" (Just 3600)\r\n\r\n    -- NOTE: We're using initJsonFileAuthManager here because it's easy and\r\n    -- doesn't require any kind of database server to run.  In practice,\r\n    -- you'll probably want to change this to a more robust auth backend.\r\n    a <- nestSnaplet \"auth\" auth $\r\n           initJsonFileAuthManager defAuthSettings sess \"users.json\"\r\n    addRoutes routes\r\n    addAuthSplices h auth\r\n    return $ App h s a\r\n```\r\n\r\nWe are going to keep the handlers around so that later we can use the `auth` snaplet, which is already set up for us, to secure our form.\r\n\r\n### Define a new Datatype: Tweet\r\n\r\nThe very first thing we need is a new datatype to define the data we will be capturing in our form. In our case, Twitter is down and the world is in a panic, so we will create a `Tweet` in a new file `src/Twitter.hs` to build a new Twitter.\r\n\r\nWe will also include some module boilerplate so we can export our awesome new datatypes and functions.\r\n\r\n```haskell\r\n{-# LANGUAGE OverloadedStrings #-}\r\nmodule Twitter\r\n(Tweet\r\n  ) where\r\n\r\nimport qualified Data.Text as T\r\n\r\ndata Tweet = Tweet {\r\n  username :: T.Text,\r\n  timestamp :: Int,\r\n  content :: T.Text\r\n} deriving (Show)\r\n```\r\n\r\nIn this example[^4], we have created a new `Tweet` datatype using [record syntax][rsyntax]. Our `Tweet` has a field for `username` and `content`, which are both of type `T.Text`[^1], and a field for a `timestamp` which we are going to deal with as an Integer (for example, the current epoch time, for me writing this, is 1391490698).\r\n\r\nThe beginning of the file says that our module name is `Twitter` (so if we were going to import it, we would write `import Twitter`). We also export the `Tweet` data type so that after importing it (in some other file), we can use `Tweet` to create new Tweets.\r\n\r\nAlso, since we are using `Data.Text` we import it `as T`.\r\n\r\nWe can check out our fancy new datatype using `ghci src/Twitter.hs`. This starts up Haskell's interpreter for the compiler we are using (ghc). Once inside the prompt, we can run `Tweet \"MyAwesomeUsername\" 1234567 \"42 is the answer!\"` to see how a `Tweet` is constructed. It looks somthing like this:\r\n\r\n```haskell\r\n*Twitter> Tweet \"MyAwesomeUsername\" 1234567 \"42 is the answer!\"\r\nTweet {username = \"MyAwesomeUsername\",\r\n       timestamp = 1234567,\r\n       content = \"42 is the answer!\"}\r\n```\r\n\r\n`:q` will get us out of the prompt.\r\n\r\n### Creating the Form\r\n\r\nNow we can create our forms. Since we are using Digestive Functors with Snap and Heist we will need a couple imports. Digestive Functors can be used in other contexts, including against JSON data.\r\n\r\n```Haskell\r\nimport           Text.Digestive\r\nimport           Text.Digestive.Heist\r\nimport           Text.Digestive.Snap\r\n```\r\n\r\nAlong with these imports, we need to tell cabal what packages to include when installing. Add these digestive-functor imports to `df-one.cabal`.\r\n\r\n```Haskell\r\n  Build-depends:\r\n    bytestring                >= 0.9.1   && < 0.11,\r\n    heist                     >= 0.13    && < 0.14,\r\n    MonadCatchIO-transformers >= 0.2.1   && < 0.4,\r\n    mtl                       >= 2       && < 3,\r\n    snap                      >= 0.11    && < 0.13,\r\n    snap-core                 >= 0.9     && < 0.11,\r\n    snap-server               >= 0.9     && < 0.11,\r\n    snap-loader-static        >= 0.9     && < 0.10,\r\n    text                      >= 0.11    && < 0.12,\r\n    time                      >= 1.1     && < 1.5,\r\n    xmlhtml                   >= 0.1,\r\n    digestive-functors        >=0.6.1    && <0.7,\r\n    digestive-functors-snap   >= 0.6.0.0 && < 0.7.0.0,\r\n    digestive-functors-heist  == 0.7.0.0\r\n```\r\n\r\nNow we are going to construct the actual form. We'll use a helper function `isNotEmpty` to check the inputs and make sure they aren't empty. `isNotEmpty` will take a `T.Text` and return a `Bool` to us.\r\n\r\n```Haskell\r\nisNotEmpty :: T.Text -> Bool\r\nisNotEmpty = not . T.null\r\n```\r\n\r\nWe will also define some error strings to display if the input isn't quite right.\r\n\r\n```Haskell\r\nuserErrMsg :: T.Text\r\nuserErrMsg = \"Username can not be empty\"\r\ntsErrMsg :: T.Text\r\ntsErrMsg = \"timestamp must be an Int\"\r\ncontentErrMsg :: T.Text\r\ncontentErrMsg = \"Tweet can not be empty\"\r\n```\r\n\r\nWe can then use these in our form:\r\n\r\n```Haskell\r\ntweetForm :: (Monad m) => Form T.Text m Tweet\r\ntweetForm = Tweet\r\n  <$> \"username\" .: check userErrMsg isNotEmpty (text Nothing)\r\n  <*> \"timestamp\" .: stringRead tsErrMsg Nothing\r\n  <*> \"content\"   .: check contentErrMsg isNotEmpty (text Nothing)\r\n```\r\n\r\nWe are using a simple `check` function which takes an error string, a test function and a form to validate. This may seem a little confusing, until we examine that `text`[^2] returns a `Formlet` for us.\r\n\r\nIn the case of `text`, we can choose to specify a default value (for use as the username or content). Currently we have `Nothing`, or no default value. The alternative is `Just \"sometext\"`, which is a default value of `sometext`.\r\n\r\n`stringRead` is similar to `text`, but for parseable and serializable values, such as our `Int`. `stringRead` takes an error string. After giving it an error string, the combination of `stringRead \"error string\"` acts exactly the same as `text`, which means we get to specify a default value. Again either `Nothing` or `Just 5`[^3].\r\n\r\nThe `<$>` and `<*>` operators come from Control.Applicative and we have to import it to use them:\r\n\r\n```Haskell\r\nimport Control.Applicative\r\n```\r\n\r\nOur `Twitter.hs` now looks like this:\r\n\r\n```Haskell\r\n{-# LANGUAGE OverloadedStrings #-}\r\nmodule Twitter\r\n(Tweet\r\n  ) where\r\n\r\nimport qualified Data.Text as T\r\nimport           Text.Digestive\r\nimport           Text.Digestive.Heist\r\nimport           Text.Digestive.Snap\r\nimport           Control.Applicative\r\n\r\ndata Tweet = Tweet {\r\n  username :: T.Text,\r\n  timestamp :: Int,\r\n  content :: T.Text\r\n} deriving (Show)\r\n\r\nisNotEmpty :: T.Text -> Bool\r\nisNotEmpty = not . T.null\r\n\r\nuserErrMsg :: T.Text\r\nuserErrMsg = \"Username can not be empty\"\r\ntsErrMsg :: T.Text\r\ntsErrMsg = \"timestamp must be an Int\"\r\ncontentErrMsg :: T.Text\r\ncontentErrMsg = \"Tweet can not be empty\"\r\n\r\ntweetForm :: (Monad m) => Form T.Text m Tweet\r\ntweetForm = Tweet\r\n  <$> \"username\" .: check userErrMsg isNotEmpty (text Nothing)\r\n  <*> \"timestamp\" .: stringRead tsErrMsg Nothing\r\n  <*> \"content\" .: check contentErrMsg isNotEmpty (text Nothing)\r\n```\r\n\r\nIn ghci, we can play around with the form a bit and see what happens.\r\n\r\n```bash\r\nghci src/Twitter.hs\r\n```\r\n\r\ngets us into the prompt and `getForm` will give us the resulting view:\r\n\r\n```Haskell\r\n*Twitter> getForm \"MyTweetForm\" tweetForm\r\n\r\nView \"thing\" [] App\r\n  App\r\n    Map _\r\n      Ref \"username\"\r\n        Map _\r\n          Pure (Text \"\")\r\n    Ref \"timestamp\"\r\n      Map _\r\n        Pure (Text \"\")\r\n  Ref \"content\"\r\n    Map _\r\n      Pure (Text \"\")\r\n [] [] Get\r\n```\r\n\r\n### Building The Heist Templates\r\n\r\nBefore we can render out our form we should write a template. `Text.Digestive.Heist` gives us some splices (bits of Heist templates) that we can use to render out our form.\r\n\r\nIn a new template file at `snaplets/heist/templates/tweetform.tpl`\r\n\r\n```Haskell\r\n<apply template=\"base\">\r\n  <dfForm action=\"/tweet\">\r\n    <dfChildErrorList ref=\"\" />\r\n\r\n    <dfLabel ref=\"username\">Username: </dfLabel>\r\n    <dfInputText ref=\"username\" />\r\n    <br>\r\n\r\n    <dfLabel ref=\"timestamp\">Timestamp: </dfLabel>\r\n    <dfInput ref=\"timestamp\" type=\"number\" min=\"0\" step=\"1\" pattern=\"\\d+\" />\r\n    <br>\r\n\r\n    <dfLabel ref=\"content\">Content: </dfLabel>\r\n    <dfInputTextArea ref=\"content\" />\r\n    <br>\r\n\r\n    <dfInputSubmit value=\"Submit\" />\r\n  </dfForm>\r\n</apply>\r\n```\r\n\r\nThe tags that start with `df` are processed by Digestive Functors before displaying. We are using a couple different tags: `dfForm`, `dfChildErrorList`, `dfLabel`, `dfInputText`, `dfInput`, `dfInputTextArea` and `dfInputSubmit`. We will go into these a bit more at the end of this chapter, but for now the important part is `ref`, which Digestive Functors uses to identify form elements.\r\n\r\nWhen rendered without errors (and a form name of \"tweet\", more on that in a sec), this template will look like this:\r\n\r\n```html\r\n<form action=\"/tweet\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\">\r\n    \r\n    <label for=\"tweet.username\">Username: </label>\r\n    <input type=\"text\" id=\"tweet.username\" name=\"tweet.username\" value=\"\">\r\n    <br>\r\n\r\n    <label for=\"tweet.timestamp\">Timestamp: </label>\r\n    <input type=\"number\" min=\"0\" step=\"1\" pattern=\"\\d+\" id=\"tweet.timestamp\" name=\"tweet.timestamp\" value=\"\">\r\n    <br>\r\n\r\n    <label for=\"tweet.content\">Content: </label>\r\n    <textarea id=\"tweet.content\" name=\"tweet.content\"></textarea>\r\n    <br>\r\n\r\n    <input value=\"Submit\" type=\"submit\">\r\n</form>\r\n```\r\n\r\nYou'll notice that the field ids and names are all namespaced by the form name (tweet). We also get a couple things for free, including encodingtype, method, some types and values.\r\n\r\nThese values will keep the values that are input if there are errors in other fields and the errors will be displayed at the top of the form.\r\n\r\n### The FormHandler Routing Function\r\n\r\nWe can now write our Snap Form Handler:\r\n\r\n```Haskell\r\ntweetFormHandler :: Handler App App ()\r\ntweetFormHandler = do\r\n  (view, result) <- runForm \"tweet\" tweetForm\r\n  case result of\r\n    Just x  -> writeText $ T.pack $ show x\r\n    Nothing -> heistLocal (bindDigestiveSplices view) $ render \"tweetform\"\r\n```\r\n\r\nWe now need to export `tweetFormHandler` so we can use it later.\r\n\r\n```Haskell\r\nmodule Twitter\r\n(Tweet\r\n,tweetFormHandler  ) where\r\n```\r\n\r\nRemember when we used `getForm` to test our form in ghci? Well it so happens that Digestive Functors Snap has a function that will automatically choose between `getForm` and `postForm` for us based on the type of request. It is called `runForm`. In addition, runForm takes the form name that we saw in the html before (\"tweet\"). This name can be any string we want and our forms will automatically be namespaced by it.\r\n\r\nEssentially what's going on here is that if we can parse a `Tweet` datatype, result is where it will be stored and `Just x` will match in our case statement. If we can't parse a `Tweet`, result will be `Nothing` and the `view` will be rendered out with our `tweetform` template. `bindDigestiveSplices` is what allows us to use the `dfInput` and other `df` tags in our html.\r\n\r\nWe also need some more imports. I've imported only what we need from Snap.Core and Snap.Snaplet.Heist to make it more obvious where these functions are coming from. In the future, to import the whole modules, you can delete the parentheses and the text inside them.\r\n\r\n```Haskell\r\nimport           Snap.Core (writeText)\r\nimport           Snap.Snaplet\r\nimport           Snap.Snaplet.Heist (heistLocal, render)\r\nimport           Application\r\n```\r\n\r\n### Final Steps\r\n\r\nNow that we have everything set up in `src/Twitter.hs` and our template written, let's go into `src/Site.hs` and create a route. First we'll add Twitter to our list of imports.\r\n\r\n```Haskell\r\nimport           Control.Applicative\r\nimport           Data.ByteString (ByteString)\r\nimport           Data.Maybe\r\nimport qualified Data.Text as T\r\nimport           Snap.Core\r\nimport           Snap.Snaplet\r\nimport           Snap.Snaplet.Auth\r\nimport           Snap.Snaplet.Auth.Backends.JsonFile\r\nimport           Snap.Snaplet.Heist\r\nimport           Snap.Snaplet.Session.Backends.CookieSession\r\nimport           Snap.Util.FileServe\r\nimport           Heist\r\nimport qualified Heist.Interpreted as I\r\nimport           Twitter\r\n```\r\n\r\nNow we can add our `tweetFormHandler` to our routes. Since our form is already set up to POST to /tweet, we'll use that as our route:\r\n\r\n```Haskell\r\n------------------------------------------------------------------------------\r\n-- | The application's routes.\r\nroutes :: [(ByteString, Handler App App ())]\r\nroutes = [ (\"/logins\",    with auth handleLoginSubmit)\r\n         , (\"/logout\",   with auth handleLogout)\r\n         , (\"/new_user\", with auth handleNewUser)\r\n         , (\"/tweet\", tweetFormHandler)\r\n         , (\"\",          serveDirectory \"static\")\r\n         ]\r\n```\r\n\r\nThat's it. Run `cabal install` and then we can run `df-one` to run our app.\r\n\r\nVisit `localhost:8000/tweet` in a browser to see our form and error handling in action!\r\n\r\nHere is our finalized `src/Twitter.hs`\r\n\r\n```Haskell\r\n{-# LANGUAGE OverloadedStrings #-}\r\nmodule Twitter\r\n(Tweet\r\n,tweetFormHandler  ) where\r\n\r\nimport qualified Data.Text as T\r\nimport           Text.Digestive\r\nimport           Text.Digestive.Heist\r\nimport           Text.Digestive.Snap\r\nimport           Control.Applicative\r\nimport           Snap.Core (writeText)\r\nimport           Snap.Snaplet\r\nimport           Snap.Snaplet.Heist (heistLocal, render)\r\nimport           Application\r\n\r\ndata Tweet = Tweet {\r\n  username :: T.Text,\r\n  timestamp :: Int,\r\n  content :: T.Text\r\n} deriving (Show)\r\n\r\nisNotEmpty :: T.Text -> Bool\r\nisNotEmpty = not . T.null\r\n\r\nuserErrMsg :: T.Text\r\nuserErrMsg = \"Username can not be empty\"\r\ntsErrMsg :: T.Text\r\ntsErrMsg = \"timestamp must be an Int\"\r\ncontentErrMsg :: T.Text\r\ncontentErrMsg = \"Tweet can not be empty\"\r\n\r\ntweetForm :: (Monad m) => Form T.Text m Tweet\r\ntweetForm = Tweet\r\n  <$> \"username\" .: check userErrMsg isNotEmpty (text Nothing)\r\n  <*> \"timestamp\" .: stringRead tsErrMsg Nothing\r\n  <*> \"content\" .: check contentErrMsg isNotEmpty (text Nothing)\r\n\r\ntweetFormHandler :: Handler App App ()\r\ntweetFormHandler = do\r\n  (view, result) <- runForm \"tweet\" tweetForm\r\n  case result of\r\n    Just x  -> writeText $ T.pack $ show x\r\n    Nothing -> heistLocal (bindDigestiveSplices view) $ render \"tweetform\"\r\n```\r\n\r\n\r\n[^1]: If you don't know what this is, it would be a good idea to look up the difference between `ByteString`, `Text` and `String` at some point.\r\n\r\n[^2]: and a bunch of other functions we will examine later such as `bool`, `optionalText` and `utcTimeFormlet`\r\n\r\n[^3]: More on Maybe here: http://learnyouahaskell.com/a-fistful-of-monads#getting-our-feet-wet-with-maybe\r\n\r\n[^4]: OverloadedStrings is a commonly used language extension that makes it easier to write string literals and use them in our application.\r\n\r\n[rsyntax]: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax","google":"UA-46878058-2","note":"Don't delete this file! It's used internally to help with page regeneration."}