
# Datatypes

Now that we've connected Postgres, we should start using it. To do
that we'll add the ability to "tweet" to Pulsar.

## Adding a datatype

The first action we will take is to create a datatype that represents
our "tweet".

### src/Pulsar/Types.hs

We are going to use some newtypes, so it's useful to enable the
`GeneralizedNewtypeDeriving` language pragma at the top of our
file. This language pragma enables us to derive the `FromField`
instances that already exist for our newtypes, saving us some typing.

```haskell
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
```

Next, a few imports.

```haskell
import           Control.Applicative                  ((<$>), (<*>))
import           Data.Text                            (Text)
import           Data.Time.Clock                      (UTCTime)
import           Database.PostgreSQL.Simple.FromField (FromField (..))
import           Snap.Snaplet.PostgresqlSimple        (FromRow (..), field)
```

Our main datatype comes next. This is the datatypes that will come
from Postgres when we query for microblogs.

```haskell
data Microblog = Microblog { id         :: MicroblogID
                           , content    :: Blog
                           , author     :: Username
                           , created_at :: UTCTime } deriving (Show)
```

We have defined `MicroblogID`, `Blog` and `Username` types, so we need
to create them. We can think of these as aliases for the types they
represent and will allow us to define functions the take a `Username`
instead of an arbitrary `Text`. We also derive `FromField` (we can do
this because of `GeneralizedNewtypeDeriving`) since `Text` and `Int`
already have `FromField` [instances][fromfield].

```haskell
newtype MicroblogID = MicroblogID Int deriving (Show, FromField)
newtype Username = Username Text deriving (Show, FromField)
newtype Blog = Blog Text deriving (Show, FromField)
```

Now we'll create a simple type, using the `newtype`s we just created,
that will represent data going into Postgres. Since the id and
timestamp are generated by Postgres, our `ToPGMicroblog` only needs a
`Blog` and a `Username`.

```
data ToPGMicroblog = ToPGMicroblog Blog Username
```

lastly, we need a `FromRow` instance for our `Microblog`, so we can
translate from Postgres Rows to our datatype. Essentially we just need
to match the number of `field` calls to the number of fields in our
datatype (`Microblog`)

```haskell
instance FromRow Microblog where
  fromRow = Microblog
            <$> field
            <*> field
            <*> field
            <*> field
```

### pulsar.cabal

Since we have imported from `Database.PostgreSQL.Simple.FromField`
we will need to add `postgresql-simple`, the library that
`snaplet-postgresql-simple` uses, to the build-depends in our .cabal
file:

```haskell
    snaplet-postgresql-simple >= 1.0,
    postgresql-simple         >= 0.4.9.0
```

### src/Pulsar/Microblog.hs

First, we'll need the `OverloadedStrings` pragma. This is because the
Postgres `Query` datatype has a limited API. The [docs][pgs-query] say:

> A Query is a newtype-wrapped ByteString. It intentionally exposes a
> tiny API that is not compatible with the ByteString API; this makes it
> difficult to construct queries from fragments of strings. The query
> and execute functions require queries to be of type Query.
>
> To most easily construct a query, enable GHC's OverloadedStrings
> language extension and write your query as a normal literal string.


```haskell
{-# LANGUAGE OverloadedStrings #-}
```

We'll also be exporting a few functions:

```haskell
module Pulsar.Microblog
         (getAllMicroblogs
         ,getMicroblog
         ,insertMicroblog) where
```

and importing a few:

```haskell
import           Data.Maybe                    (listToMaybe)
import           GHC.Int                       (Int64)
import           Pulsar.Types                    (Blog (..),
                                                Microblog (..),
                                                MicroblogID (..),
                                                ToPGMicroblog (..),
                                                Username (..))
import           Snap.Snaplet.PostgresqlSimple (HasPostgres (..),
                                                Only (..), execute,
                                                query, query_)
```

First, we'll write a query to retrieve all Microblogs. The only
restriction we need is a `HasPostgres` instance on `m`. `with pg`
gives us a Snap handler with a `HasPostgres` instance, as we will see
shortly.

```haskell
getAllMicroblogs :: (HasPostgres m) => m [Microblog]
getAllMicroblogs = query_ "SELECT * FROM microblogs"
```

Next, a query to retrieve a single Microblog. Once again we need
access to Postgres, so we need an `m` with a `HasPostgres`
instance. Then we take a `MicroblogID` to look for a record matching
that id and use [`listToMaybe`][listToMaybe] to return `Nothing` if there are no
results and `Just Microblog` if there is a result.

```haskell
getMicroblog
  :: (HasPostgres m)
  => MicroblogID
  -> m (Maybe Microblog)
getMicroblog (MicroblogID m_id) = do
  r <- query "SELECT * FROM microblogs WHERE id = ?" (Only m_id)
  return $ listToMaybe r
```

Finally, a query to insert a single Microblog. We will use the
`ToPGMicroblog` datatype we created earlier and pattern-match the
`Blog` and `Username` out so we can insert them in the `Query` using a
tuple. Multiline strings in Haskell are denoted by `\` at the end of
the line and a `\` at the beginning of the next piece of the string.

```haskell
insertMicroblog :: (HasPostgres m)
                => ToPGMicroblog
                -> m Int64
insertMicroblog (ToPGMicroblog (Blog blog)  (Username user)) =
  execute "INSERT INTO \
          \microblogs (content, author)\
          \VALUES (?, ?)" (blog, user)
```

### src/Pulsar/Handlers.hs

Now we will write a couple test handlers to make sure our datatype
gets into and out of Postgres cleanly. Again, we start with the
`OverloadedStrings` pragma and some imports.

```haskell
{-# LANGUAGE OverloadedStrings #-}
module Pulsar.Handlers where

import qualified Data.Text                     as T (pack)
import           Pulsar.Microblog                (getAllMicroblogs,
                                                getMicroblog,
                                                insertMicroblog)
import           Pulsar.Types                    (Blog (..),
                                                MicroblogID (..),
                                                ToPGMicroblog (..),
                                                Username (..))
import           Snap                          (Handler, writeText)
import           Snap.Snaplet.PostgresqlSimple (Postgres)
```

Then, a fake microblog entry.

```haskell
microblog :: ToPGMicroblog
microblog = ToPGMicroblog (Blog "My awesome microblog!") (Username "biscarch")
```

with the fake microblog entry, we don't have to worry about getting
user input while testing. Here we use our `insertMicroblog` function
to send our fake microblog to postgres. Postgress will give us back
the number of rows affected (`rowsAffected`) and we write that number
out as the HTTP response. (note that `writeText` doesn't actually send
data, roughly speaking; it queues data to be sent later)

```haskell
insertTest :: Handler b Postgres ()
insertTest = do
           rowsAffected <- insertMicroblog microblog
           writeText $ T.pack $ show rowsAffected
```

Of course after inserting records, we will want to retrieve them all:

```haskell
getAllTest :: Handler b Postgres ()
getAllTest = do
           mblogs <- getAllMicroblogs
           writeText $ T.pack $ show mblogs
```

As well as retrieve them one at a time. In this case, `getMicroblog`
gives us back a `Maybe Microblog`, so we use `case` to pattern match
on the possible return values.

```haskell
getOneTest :: Handler b Postgres ()
getOneTest = do
           mblog <- getMicroblog (MicroblogID 1)
           case mblog of
             Nothing -> writeText "No Blog"
             Just b -> writeText $ T.pack $ show b
```

### src/Site.hs

Finally, we can add these routes to our site. We'll need to import the
handlers:

```haskell
import Pulsar.Handlers (insertTest, getAllTest, getOneTest)
```

In our `routes` declaration, we will add three routes. One for each
Handler. Each handled is restricted to matching on a specific kind of
HTTP request (one POST and two GETs), then they declare that the
handler is going to use `pg`, which is from our App datatype. `with
pg` is what makes our Handlers have the type `Handler b Postgres`.

```haskell
, ("/insert", method POST $ with pg $ insertTest)
, ("/show", method GET $ with pg $ getAllTest)
, ("/show/one", method GET $ with pg $ getOneTest)
```

## Testing Routes

### Checking /insert

We can build and run with `docker-compose`:

```bash
> docker-compose build pulsar
> docker-compose up pulsar
```

Then we can hit our endpoint a couple times with `curl` to insert the
sample microblog:

```bash
curl -XPOST 192.168.59.103:8000/insert -d ""
curl -XPOST 192.168.59.103:8000/insert -d ""
```

docker-compose will tell us what containers are running (and what
their names are):

```bash
docker-compose ps
      Name                    Command               State           Ports
----------------------------------------------------------------------------------
datatypes_pulsar_1 /opt/pulsar/dist/build/puls...   Up      0.0.0.0:8000->8000/tcp
datatypes_pg_1     /docker-entrypoint.sh postgres   Up      5432/tcp
```

We want our database `datatypes_pg_1`. We will use psql inside of the
container to check out what data we have in the `microblogs` table:

```bash
> docker exec -it datatypes_pg_1 bash
root@7d48e25f4bf2:/# psql -h "$POSTGRES_PORT_5432_TCP_ADDR" \
  -p "$POSTGRES_PORT_5432_TCP_PORT" -U postgres
psql (9.4.1)
Type "help" for help.

postgres=# \d
No relations found.
postgres=# \c testdb
You are now connected to database "testdb" as user "postgres".
testdb=# \d
                  List of relations
 Schema |          Name          |   Type   |  Owner
--------+------------------------+----------+----------
 public | microblogs             | table    | postgres
 public | microblogs_id_seq      | sequence | postgres
 public | snap_auth_user         | table    | postgres
 public | snap_auth_user_uid_seq | sequence | postgres
(4 rows)

testdb=# select * from microblogs;
 id |        content        |  author  |         created_at
----+-----------------------+----------+----------------------------
  1 | My awesome microblog! | biscarch | 2015-02-14 18:19:50.168034
  2 | My awesome microblog! | biscarch | 2015-02-14 18:19:57.498736
(2 rows)

testdb=#
```

Great! We have two microblogs because we ran the `curl` commands twice.

### Checking /show

We can also use our new route to get all microblogs:

```bash
> curl 192.168.59.103:8000/show
[Microblog {mid = MicroblogID 1, content = Blog "My awesome
microblog!", author = Username "biscarch", created_at =
2015-02-14 19:39:21.461028 UTC},Microblog {mid = MicroblogID 2
, content = Blog "My awesome microblog!", author = Username
"biscarch", created_at = 2015-02-14 19:39:22.51694 UTC}]%
```

### Checking /show/one

```bash
> curl 192.168.59.103:8000/show/one
Microblog {mid = MicroblogID 1, content = Blog "My awesome
microblog!", author = Username "biscarch", created_at = 2015-02-14
19:39:21.461028 UTC}%
```

Receiving the microblogs would be more useful in an HTML or JSON response.
